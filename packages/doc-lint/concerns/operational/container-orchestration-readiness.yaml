# =============================================================================
# CONCERN: Container Orchestration Readiness
# =============================================================================
# This concern validates that containerized services document resource profiles
# (CPU/memory limits) and health check endpoints. Without these, orchestrators
# cannot make informed scheduling decisions, and unhealthy containers continue
# receiving traffic.
#
# WHY THIS MATTERS:
# Container orchestrators like Kubernetes rely on declared resource limits and
# health checks to schedule pods, evict unhealthy instances, and prevent noisy
# neighbors. Services deployed without resource limits can starve co-located
# workloads. Services without health checks continue receiving traffic even
# when they're deadlocked, out of memory, or unable to serve requests.
# =============================================================================

concern:
  id: "container-orchestration-readiness"
  version: "1.0"
  name: "Container Orchestration Readiness"
  category: "operational"
  severity: "warn"

  description: |
    Every containerized service must document:
    1. Resource profiles (CPU and memory requests/limits)
    2. Health check endpoints (liveness and readiness probes)
    3. Health check type and configuration (HTTP, TCP, exec)
    4. Graceful shutdown behavior (SIGTERM handling, drain period)

# -----------------------------------------------------------------------------
# TRIGGERS: When to load this concern
# -----------------------------------------------------------------------------
triggers:
  any_of:
    - containerization
    - kubernetes

# -----------------------------------------------------------------------------
# EVALUATION: The reasoning task
# -----------------------------------------------------------------------------
evaluation:
  question: |
    Systematically identify every containerized service in the documented
    system, then evaluate whether each has documented resource profiles and
    health check endpoints.

    STEP 1: IDENTIFY CONTAINERIZED SERVICES
    Scan all documents for services running in containers:
    - Docker containers, Kubernetes pods/deployments
    - ECS tasks, Cloud Run services, Azure Container Instances
    - Any service described with container images, Dockerfiles, or
      container orchestration configuration
    - Look for: container, docker, pod, deployment, helm, k8s, ECS

    STEP 2: FOR EACH SERVICE, CHECK RESOURCE PROFILES
    a) CPU limits:
       - Are CPU requests and limits documented?
       - Are they based on load testing or profiling data?
    b) Memory limits:
       - Are memory requests and limits documented?
       - Is there headroom for garbage collection / memory spikes?
    c) Are resource profiles different per environment (dev/staging/prod)?

    STEP 3: FOR EACH SERVICE, CHECK HEALTH CHECKS
    a) Liveness probe:
       - Is there a liveness check? (determines if container should restart)
       - What type? (HTTP endpoint, TCP socket, exec command)
       - What are the timing parameters? (initial delay, period, threshold)
    b) Readiness probe:
       - Is there a readiness check? (determines if container receives traffic)
       - Does it check downstream dependencies?
       - What happens during startup? (readiness gates)
    c) Startup probe (if applicable):
       - For slow-starting services, is there a startup probe?

    STEP 4: FLAG GAPS
    Any containerized service without documented resource limits or health
    checks is a gap.

  checklist:
    - id: "service-inventory"
      question: "Are all containerized services identified with their orchestration platform?"
    - id: "resource-limits"
      question: "Does each service document CPU and memory requests/limits?"
    - id: "health-checks"
      question: "Does each service have documented liveness and readiness probes?"
    - id: "graceful-shutdown"
      question: "Does each service document SIGTERM handling and drain period?"

  evidence_required:
    - field: "service_name"
      type: "string"
      description: "Name of the containerized service (e.g., 'OrderService pod', 'PaymentWorker ECS task')"
      required: true

    - field: "resource_limits_documented"
      type: "boolean"
      description: "Whether CPU and memory requests/limits are documented"
      required: true

    - field: "health_check_documented"
      type: "boolean"
      description: "Whether liveness and/or readiness probes are documented"
      required: true

    - field: "health_check_type"
      type: "string | null"
      description: "Type of health check (e.g., 'HTTP GET /healthz', 'TCP port 8080', 'exec: pg_isready')"
      required: true

    - field: "source_location"
      type: "string"
      description: "Where this service is documented (e.g., 'ADD Section 5.1 - Deployment Architecture')"
      required: true

    - field: "confidence"
      type: "enum"
      values: ["high", "medium", "low"]
      description: "Your confidence that this assessment is accurate"
      required: true

  failure_condition: |
    Report as ERROR when ANY of the following are true:

    1. A production service has resource_limits_documented = FALSE and
       health_check_documented = FALSE - the service is completely
       unprepared for orchestration

    Report as WARNING when:

    1. resource_limits_documented = FALSE - the orchestrator cannot make
       informed scheduling decisions

    2. health_check_documented = FALSE - unhealthy containers continue
       receiving traffic

    3. health_check_type is only liveness without readiness - the service
       may receive traffic before it's ready

    4. Resource limits are documented but appear to be placeholder values
       (e.g., "256Mi" for a JVM service that needs at least 512Mi)

  recommendation_template: |
    ## Gap: {service_name} - Missing Container Orchestration Config

    **Location:** {source_location}

    ### Required Documentation

    1. **Resource Profiles**
       - CPU request/limit (e.g., "request: 250m, limit: 1000m")
       - Memory request/limit (e.g., "request: 512Mi, limit: 1Gi")
       - Basis for values (load test results, profiling data)

    2. **Health Checks**
       - Liveness probe: endpoint, type, timing
       - Readiness probe: endpoint, type, timing
       - Example: "Liveness: HTTP GET /healthz every 10s, 3 failures to restart.
         Readiness: HTTP GET /ready every 5s, checks DB connectivity."

    3. **Graceful Shutdown**
       - SIGTERM handling behavior
       - Drain period for in-flight requests
       - Example: "On SIGTERM, stop accepting new requests, drain existing
         requests for up to 30s, then exit."

# -----------------------------------------------------------------------------
# EXAMPLES
# -----------------------------------------------------------------------------
examples:
  well_documented:
    - source: "ADD Section 5.1 - Kubernetes Deployment"
      text: |
        "OrderService runs as a Kubernetes Deployment with 3 replicas.
        Resources: CPU request 250m/limit 1000m, memory request 512Mi/limit 1Gi.
        Liveness: HTTP GET /healthz every 10s, 3 failures triggers restart.
        Readiness: HTTP GET /ready every 5s, checks DB and Redis connectivity.
        On SIGTERM, drains in-flight requests for 30s before exit."
      assessment: |
        service_name: "OrderService Kubernetes Deployment"
        resource_limits_documented: true
        health_check_documented: true
        health_check_type: "HTTP GET /healthz (liveness), HTTP GET /ready (readiness)"
        confidence: "high"

  poorly_documented:
    - source: "ADD Section 4.2"
      text: |
        "The notification service runs in Docker containers managed by ECS."
      assessment: |
        service_name: "Notification service (ECS)"
        resource_limits_documented: false
        health_check_documented: false
        health_check_type: null
        confidence: "high"
        gap: "No resource limits or health checks documented. ECS cannot
              make informed placement decisions, and unhealthy containers
              will continue receiving traffic."

# -----------------------------------------------------------------------------
# METADATA
# -----------------------------------------------------------------------------
metadata:
  created: "2026-02"
  last_updated: "2026-02"
  tier: 2
  author: "Multi-Expert Consensus (Claude, Gemini, Codex)"
  related_concerns:
    - "failure-mode-coverage"
    - "alerting-slo-alignment"
  references:
    - "Kubernetes: Configure Liveness, Readiness and Startup Probes"
    - "Kubernetes: Resource Management for Pods and Containers"
